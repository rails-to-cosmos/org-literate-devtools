# -*- lexical-binding: t; -*-

#+TITLE: org-literate-devtools
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-literate-devtools
#+PROPERTY: header-args:emacs-lisp :noweb yes :tangle yes :results silent

* Hello
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-

;;; oldt.el --- org-driven development

;; Copyright (C) 2019 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 17 Feb 2019
;; Version: 0.1

;; Keywords: org devtools babel
;; Homepage: https://github.com/rails-to-cosmos/oldt

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+end_src
* Core
** requirements
#+begin_src emacs-lisp
(require 'aio)
(require 'ert)
(require 'org)
(require 'org-capture)
#+end_src
** org-element helpers
*** headline-tags
#+begin_src emacs-lisp
(defun oldt-headline-contains-tags-p (&rest tags)
  (equal (seq-intersection tags (org-get-tags)) tags))
#+end_src
*** get-node-property
#+begin_src emacs-lisp
(defun oldt-get-node-property (property)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (alist-get property (org-entry-properties) nil nil #'string=)))
#+end_src
*** search-ancestor
#+begin_src emacs-lisp
(defun oldt-search-ancestor (predicate)
  (save-excursion
    (org-with-wide-buffer
     (unless (org-at-heading-p)
       (org-back-to-heading))
     (loop-until (or (funcall predicate)
                     (null (org-up-heading-safe))))
     (when (funcall predicate)
       (point-marker)))))
#+end_src
** start-process-async
#+begin_src emacs-lisp
(aio-defun oldt-start-process-async (pname buf &rest args)
  (message "Start process \"%s\"" pname)
  (let* ((proc (apply #'start-process pname buf args)))
    (while (string= (process-status proc) "run")
      (aio-await (aio-sleep 1)))
    (message "Process \"%s\" exited with code %s" pname (process-exit-status proc))
    (process-exit-status proc)))
#+end_src
* Features
** Projects
*** at-project?
#+begin_src emacs-lisp
(defun oldt-at-project-p ()
  (save-excursion
    (when (eq (buffer-mode) 'org-mode)
      (org-back-to-heading)
      (org-beginning-of-line)
      (plist-get (org-element--get-node-properties) :PROJECT))))
#+end_src
*** menu
#+begin_src emacs-lisp
(defun oldt-project-menu ()
  (interactive)
  (let ((items `("service-eshell"
                 "service-browse-repo"
                 "service-browse-deploy"
                 "service-browse-logs"
                 "service-browse-url"

                 "service-docker-compose-config"
                 "service-docker-compose-down"
                 "service-docker-compose-restart"
                 "service-docker-compose-up"
                 "service-docker-container-dired"
                 "service-docker-container-eshell"
                 "service-docker-container-logs"

                 "project-browse-ticket"
                 "project-insert-ticket"
                 "project-insert-branch"

                 "task-insert-commit-message"
                 "task-browse-pull-request")))
    (if-let (project-name (oldt-project-get-property "ITEM"))
        (-some->> items
                  (org-completing-read (concat project-name ": "))
                  (concat "oldt-")
                  (intern)
                  (funcall))
      (message "Unable to find project."))))

(defun oldt-project-insert-ticket ()
  (interactive)
  (insert (oldt-project-get-property "TICKET")))

(defun oldt-project-insert-branch ()
  (interactive)
  (insert (oldt-project-get-property "BRANCH")))
#+end_src
*** tangle-project
#+begin_src emacs-lisp
(defun oldt-tangle-buffer ()
  (org-element-map (org-element-parse-buffer 'element) 'src-block
    (lambda (datum)
      (let ((point (org-element-property :begin datum)))
        (org-with-point-at point
          (oldt-tangle-relatives))))))

(defun oldt-tangle-subtree-at-point ()
  (interactive)
  (save-restriction
    (condition-case nil
        (org-narrow-to-subtree)
      (error nil))
    (oldt-tangle-buffer)))

(defun oldt-tangle-project ()
  (interactive)
  (save-excursion
    (oldt-goto-project)
    (oldt-tangle-subtree-at-point)))
#+end_src
*** compile-project
#+begin_src emacs-lisp
(defun oldt-compile-project()
  (interactive)
  (oldt-tangle-project)
  (let ((cmd (oldt-ensure-local-var 'compile-command)))
    (save-excursion
      (oldt-goto-project)
      (save-window-excursion
        (oldt-goto-tangle-file)
        (compile cmd))))

  (switch-to-buffer-other-window "*compilation*"))
#+end_src
*** search-project
#+begin_src emacs-lisp
(defun oldt-search-project ()
  (cond ((and (org-at-heading-p) (oldt-at-project-p)) t)
        ((org-clocking-p) (progn
                            (org-clock-goto)
                            (org-beginning-of-line)
                            t))
        (t nil))
  (oldt-search-ancestor 'oldt-at-project-p))
#+end_src
*** goto-project
#+begin_src emacs-lisp
(defun oldt-goto-project ()
  (interactive)
  (org-goto-marker-or-bmk (oldt-search-project)))
#+end_src
*** project-get-property
#+begin_src emacs-lisp
(defun oldt-project-get-property (property)
  (save-window-excursion
    (save-excursion
      (condition-case nil
          (progn
            (oldt-goto-project)
            (oldt-get-node-property property))
        (error nil)))))
#+end_src
*** project-set-property
#+begin_src emacs-lisp
(defun oldt-project-set-property (property value)
  (save-window-excursion
    (save-excursion
      (oldt-goto-project)
      (cond ((string= property "ITEM")
             (let ((beg (save-excursion
                          (org-beginning-of-line)
                          (point)))
                   (end (save-excursion
                          (org-end-of-line)
                          (point))))
               (kill-region beg end)
               (org-beginning-of-line)
               (insert value)))
            ((string= property "TODO_STATE")
             (org-todo value))
            (t (org-set-property property value))))))
#+end_src
*** narrow-to-project
#+begin_src emacs-lisp
(defun oldt-narrow-to-project ()
  (interactive)
  (widen)
  (oldt-goto-project)
  (org-narrow-to-subtree)
  (org-content))
#+end_src
*** COMMENT toggle-explicit-category
#+begin_src emacs-lisp
(defun oldt-toggle-explicit-category ()
  (interactive)
  (save-excursion
    (org-back-to-heading t)
    (let ((case-fold-search nil)
          (explicit-category (format "[%s]" (org-get-category))))

      (when (looking-at org-todo-line-regexp)
        (beginning-of-line)
        (let*
            ((eol (save-excursion
                    (end-of-line)
                    (mark)))
             (category-specified-p (save-excursion
                                     (condition-case nil
                                         (progn
                                           (search-forward explicit-category eol) t)
                                       ('error nil)))))
          (when (not category-specified-p)
            (condition-case nil
                (progn (re-search-forward org-todo-regexp)
                       (insert " "))
              ('error (progn (search-forward "* ")
                             (insert " ")
                             (backward-char))))
            (insert explicit-category)))))))
#+end_src
*** browse-ticket
#+begin_src emacs-lisp
(defun oldt-project-browse-ticket ()
  (save-window-excursion
    (save-excursion
      (org-save-outline-visibility
          (when-let ((ticket (oldt-project-get-property "TICKET")))
            (oldt-goto-project)
            (when-let ((ticket-link (alist-get "ticket" org-link-abbrev-alist-local nil nil #'string=)))
              (browse-url (format ticket-link ticket))))))))
#+end_src
** Tasks
*** browse-something
#+begin_src emacs-lisp
(defun oldt-task-browse (property)
  (if-let (val (-> property
                   oldt-task-get-property
                   split-string))
      (if (> (length val) 1)
          (org-open-link-from-string
           (org-completing-read (format "Browse %s: " property) val))
        (org-open-link-from-string (car val)))))
#+end_src
*** at-task?
#+begin_src emacs-lisp
(defun oldt-at-task-p ()
  (save-excursion
    (org-back-to-heading)
    (org-beginning-of-line)
    (not (oldt-at-project-p))))
#+end_src
*** commit-messages
#+begin_src emacs-lisp
(defun oldt-task-insert-commit-message ()
  (let ((msg (read-string "Commit message: " (oldt-task-get-property "ITEM"))))
    (insert (concat (oldt-project-get-property "TICKET") ": "))
    (insert msg)
    (unless (s-ends-with-p "." msg)
      (insert "."))))
#+end_src
*** browse-pr
#+begin_src emacs-lisp
(defun oldt-task-browse-pull-request ()
  (oldt-task-browse "PULL_REQUEST"))
#+end_src
*** set-pull-request-prop
#+begin_src emacs-lisp
(defun oldt-set-pull-request-if-not-specified ()
  (when (oldt-at-task-p)
    (unless (oldt-task-get-property "PULL_REQUEST")
      (-some->> (org-read-property-value "PULL_REQUEST")
                (oldt-task-set-property "PULL_REQUEST")))
    (when (org-clocking-p)
      (let ((org-clock-out-switch-to-state "CODE_REVIEW"))
        (org-clock-out)))))
#+end_src
*** search-task
#+begin_src emacs-lisp
(defun oldt-search-task ()
  (if (cond ((org-at-heading-p) (oldt-at-task-p))
            ((org-clocking-p) (progn
                                (org-clock-goto)
                                (oldt-at-task-p)))
            (t nil))
      (point-marker)
    (error "Task not found.")))
#+end_src
*** goto-task
#+begin_src emacs-lisp
(defun oldt-goto-task ()
  (interactive)
  (let ((mark (oldt-search-task)))
    (org-goto-marker-or-bmk mark)
    mark))
#+end_src
*** task-set-property
#+begin_src emacs-lisp
(defun oldt-task-set-property (property value)
  (save-window-excursion
    (save-excursion
      (oldt-goto-task)
      (cond ((string= property "ITEM")
             (let ((beg (save-excursion
                          (org-beginning-of-line)
                          (point)))
                   (end (save-excursion
                          (org-end-of-line)
                          (point))))
               (kill-region beg end)
               (org-beginning-of-line)
               (insert value)))
            (t (org-set-property property value))))))
#+end_src
*** task-hooks
#+begin_src emacs-lisp
(defun oldt-trigger-function (change-plist)
  (let (;; (state-from (substring-no-properties (or (plist-get change-plist :from) "")))
        (state-to (substring-no-properties (or (plist-get change-plist :to) ""))))
    (when-let (magic-property (oldt-project-get-property (format "TASK_%s" state-to)))
        (save-excursion
          (oldt-goto-task)
          (eval (read magic-property))))))
(add-hook 'org-trigger-hook 'oldt-trigger-function)
#+end_src
*** get-task-property
#+begin_src emacs-lisp
(defun oldt-task-get-property (property)
  (save-window-excursion
    (save-excursion
      (let ((marker (oldt-goto-task)))
        (if (string= property "STATE")
            (substring-no-properties (org-get-todo-state))
          (org-entry-get marker property t))))))
#+end_src
** Services
*** shell
#+begin_src emacs-lisp
(defun oldt-service-eshell ()
  (spawn-custom-shell (format "*%s-eshell*" (oldt-service-get-property "ITEM"))
                      (oldt-service-get-property "PATH")))
#+end_src
*** get-property
#+begin_src emacs-lisp
(defun oldt-service-get-property (property)
  (let ((service (split-string (oldt-project-get-property "SERVICES"))))
    (setq service (if (> (length service) 1)
                      (org-completing-read "Service: " service)
                    (car service)))
    (save-window-excursion
      (save-excursion
        (org-id-goto service)
        (oldt-get-node-property property)))))
#+end_src
*** docker
#+begin_src emacs-lisp
(defun oldt-service-docker-container-dired ()
  (interactive)
  (oldt-goto-project)
  (let ((container (oldt-service-get-property "CONTAINER")))
    (org-open-link-from-string (format "[[docker:%s]]" container))))

(defun oldt-service-docker-container-logs ()
  (interactive)
  (let* ((container (oldt-service-get-property "CONTAINER"))
         (cmd (format "docker logs %s -f" container))
         (bufname (format "*docker-%s-logs*" container)))
    (get-buffer-create bufname)
    (async-shell-command cmd bufname)
    (switch-to-buffer-other-window bufname)
    (goto-char (point-max))
    ;; (special-mode)
    ;; (auto-revert-mode)
    ))

(defun oldt-service-docker-container-eshell ()
  (interactive)
  (let ((container (oldt-service-get-property "CONTAINER"))
        (service (oldt-service-get-property "ITEM")))
    (spawn-custom-shell (format "*%s-docker-container-eshell*" service)
                        (format "/docker:%s:/opt" container))))

;; (defun oldt-service-docker-container-logs ()
;;   (interactive)
;;   (oldt-goto-project)
;;   (let ((container (oldt-service-get-property "CONTAINER")))
;;     (org-open-link-from-string (format "[[docker-logs:%s]]" container))))

(defun oldt-service-docker-compose-config ()
  (let ((path (oldt-service-get-property "PATH")))
    (find-file (concat path "/docker-compose.yml"))))

(aio-defun oldt-service-start-process (pname buf &rest args)
  (let ((service (oldt-service-get-property "ITEM")))
    (message "%s: Start process \"%s\"" service pname)
    (let* ((default-directory (oldt-service-get-property "PATH"))
           (proc (apply #'start-process pname buf args)))
      (while (string= (process-status proc) "run")
        (aio-await (aio-sleep 1)))
      (message "%s: Process \"%s\" exited with status \"%s\"" service pname (process-status proc)))))

(aio-defun oldt-service-docker-compose-down ()
  (aio-await (oldt-service-start-process "docker-compose down" "*oldt-service-docker-output*" "docker-compose" "down"))
  ;; (aio-await (oldt-service-start-process "docker image prune" "*oldt-service-docker-output*" "docker" "image" "prune" "-f"))
  )

(aio-defun oldt-service-docker-compose-up ()
  (aio-await (oldt-service-start-process "docker-compose up" "*oldt-service-docker-output*"
                                         "docker-compose" "up"
                                         ;; "--force-recreate"
                                         "--build" "-d"))
  (oldt-service-docker-container-logs))

(aio-defun oldt-service-docker-compose-restart ()
  (aio-await (oldt-service-docker-compose-down))
  (aio-await (oldt-service-docker-compose-up)))
#+end_src
*** browse-repo
#+begin_src emacs-lisp
(defun oldt-service-browse-repo ()
  (when-let ((repo-url (oldt-service-get-property "REPO")))
    (org-open-link-from-string repo-url)))
#+end_src
*** browse-logs
#+begin_src emacs-lisp
(defun oldt-service-browse-logs ()
  (interactive)
  (oldt-goto-project)
  (let ((logs-url (oldt-service-get-property "LOGS")))
    (org-open-link-from-string logs-url)))
#+end_src
*** browse-deploy
#+begin_src emacs-lisp
(defun oldt-service-browse-deploy ()
  (loop for url in (split-string (oldt-service-get-property "CI"))
        do (org-open-link-from-string url)))
#+end_src
*** browse-url
#+begin_src emacs-lisp
(defun oldt-service-browse-url ()
  (let ((property "URL"))
    (if-let (val (-> property
                   oldt-service-get-property
                   split-string))
      (if (> (length val) 1)
          (org-open-link-from-string
           (org-completing-read (format "Browse %s: " property) val))
        (org-open-link-from-string (car val))))))
#+end_src
** Extended tangling
*** tangle-by-tags
#+begin_src emacs-lisp
(defun oldt-tt (&rest mappings)
  (loop for mapping in mappings
        when (or (eq (car mapping) t) ;; "else" clause
                 (apply 'oldt-headline-contains-tags-p (butlast mapping)))
        collect (car (last mapping)) into result
        finally (return (if result (car result) "no"))))
#+end_src
*** tangle-relatives
#+begin_src emacs-lisp
(defun oldt-tangle-relatives (&optional arg target-file &rest _)
  "Write code blocks to source-specific files.
Extract the bodies of all source code blocks from the current
file into their own source-specific files.
With one universal prefix argument, only tangle the block at point.
When two universal prefix arguments, only tangle blocks for the
tangle file of the block at point.
Optional argument TARGET-FILE can be used to specify a default
export file for all source blocks.  Optional argument LANG can be
used to limit the exported source code blocks by language."
  (interactive "P")
  (run-hooks 'org-babel-pre-tangle-hook)
  ;; Possibly Restrict the buffer to the current code block
  (save-restriction
    (save-excursion
      (when (equal arg '(4))
	(if-let (head (org-babel-where-is-src-block-head))
            (goto-char head)
          (user-error "Point is not in a source code block")))
      (let* ((block-counter 0) path-collector

	     (org-babel-default-header-args
	      (if target-file
	          (org-babel-merge-params org-babel-default-header-args
	        			  (list (cons :tangle target-file)))
	        org-babel-default-header-args)))
	(mapc ;; map over all languages
	 (lambda (by-lang)
	   (let* ((lang (car by-lang))
		  (specs (cdr by-lang))
		  (ext (or (cdr (assoc lang org-babel-tangle-lang-exts)) lang))
		  (lang-f (intern
			   (concat
			    (or (and (cdr (assoc lang org-src-lang-modes))
				     (symbol-name
				      (cdr (assoc lang org-src-lang-modes))))
				lang)
			    "-mode")))
		  she-banged)
	     (mapc
	      (lambda (spec)
		(let ((get-spec (lambda (name) (cdr (assoc name (nth 4 spec))))))
		  (let* ((tangle (funcall get-spec :tangle))
			 (she-bang (let ((sheb (funcall get-spec :shebang)))
                                     (when (> (length sheb) 0) sheb)))
			 (tangle-mode (funcall get-spec :tangle-mode))
			 (base-name (cond
				     ((string= "yes" tangle)
				      (file-name-sans-extension
				       (nth 1 spec)))
				     ((string= "no" tangle) nil)
				     ((> (length tangle) 0) tangle)))
			 (file-name (consider-tangle-dir
                                     (when base-name
				       ;; decide if we want to add ext to base-name
				       (if (and ext (string= "yes" tangle))
					   (concat base-name "." ext) base-name)))))
		    (when file-name
		      ;; Possibly create the parent directories for file.
		      (let ((m (funcall get-spec :mkdirp))
			    (fnd (file-name-directory file-name)))
			(and m fnd (not (string= m "no"))
			     (make-directory fnd 'parents)))
		      ;; delete any old versions of file
		      (and (file-exists-p file-name)
			   (not (member file-name (mapcar #'car path-collector)))
			   (delete-file file-name))
		      ;; drop source-block to file
		      (with-temp-buffer
			(when (fboundp lang-f) (ignore-errors (funcall lang-f)))
			(when (and she-bang (not (member file-name she-banged)))
			  (insert (concat she-bang "\n"))
			  (setq she-banged (cons file-name she-banged)))
			(org-babel-spec-to-string spec)
			;; We avoid append-to-file as it does not work with tramp.
			(let ((content (buffer-string)))
			  (with-temp-buffer
			    (when (file-exists-p file-name)
			      (insert-file-contents file-name))
			    (goto-char (point-max))
			    ;; Handle :padlines unless first line in file
			    (unless (or (string= "no" (cdr (assq :padline (nth 4 spec))))
					(= (point) (point-min)))
			      (insert "\n"))
			    (insert content)
			    (write-region nil nil file-name))))
		      ;; if files contain she-bangs, then make the executable
		      (when she-bang
			(unless tangle-mode (setq tangle-mode #o755)))
		      ;; update counter
		      (setq block-counter (+ 1 block-counter))
		      (unless (assoc file-name path-collector)
			(push (cons file-name tangle-mode) path-collector))))))
	      specs)))
         (oldt-collect-relative-blocks))

	;; run `org-babel-post-tangle-hook' in all tangled files
	(when org-babel-post-tangle-hook
	  (mapc
	   (lambda (file)
	     (org-babel-with-temp-filebuffer file
	       (run-hooks 'org-babel-post-tangle-hook)))
	   (mapcar #'car path-collector)))
	;; set permissions on tangled files
	(mapc (lambda (pair)
		(when (cdr pair) (set-file-modes (car pair) (cdr pair))))
	      path-collector)

        (message "Tangled %d code block%s from %s to %s" block-counter
		 (if (= block-counter 1) "" "s")
		 (file-name-nondirectory
		  (buffer-file-name
		   (or (buffer-base-buffer) (current-buffer))))
                 (caar path-collector))
        path-collector))))
#+end_src
*** consider tangle-dir
#+begin_src emacs-lisp
(defun consider-tangle-dir (file-name)
  (if-let (tangle-dir (get-tangle-dir-at-point))
      (when (and file-name (f-relative-p file-name))
        (f-join tangle-dir file-name))
    file-name))
#+end_src
*** tangle-dir
#+begin_src emacs-lisp
(defun get-tangle-dir-at-point ()
  (if (org-before-first-heading-p)
      ""
    (save-excursion
      (cl-loop initially (org-back-to-heading)
               with tangle-dir-at-point = (lambda () (plist-get (org-element--get-node-properties) :TANGLE_DIR))
               with tangle-dir = (when-let (tangle-dir (funcall tangle-dir-at-point))
                                   (list tangle-dir))
               for level = (org-up-heading-safe)
               for dir = (funcall tangle-dir-at-point)
               when (and level dir) collect dir into tangle-dir
               unless level return (when tangle-dir (apply 'f-join (reverse tangle-dir)))))))
#+end_src
*** collect-relatives
#+begin_src emacs-lisp
(defun oldt-collect-relative-blocks ()
  (let* ((counter 0) blocks
         (info (org-babel-get-src-block-info 'light))
         (babel-params (nth 2 info))
         (src-tfile (consider-tangle-dir (alist-get :tangle babel-params)))
         (src-lang (car info)))

    (org-babel-map-src-blocks (buffer-file-name)
      (unless (org-in-commented-heading-p)
        (let* ((info (org-babel-get-src-block-info 'light))
               (params (nth 2 info))
               (tangle-file (consider-tangle-dir (alist-get :tangle params)))
               (block (unless (or (string= src-tfile "no")
		                  (and tangle-file (not (equal tangle-file src-tfile))))
                        (cl-incf counter)
                        (org-babel-tangle-single-block counter))))
          (push (cons src-lang (list block)) blocks))))

    ;; Ensure blocks are in the correct order.
    (nreverse blocks)))
#+end_src
*** get tangle files from subtree
#+begin_src emacs-lisp
(defun oldt-collect-tangle-files-in-buffer ()
  (-distinct
   (-flatten
    (org-element-map (org-element-parse-buffer 'element) 'src-block
      (lambda (datum)
        (let* ((lang (org-element-property :language datum))
               (ext (or (cdr (assoc lang org-babel-tangle-lang-exts)) lang))
               (point (org-element-property :begin datum)))

          (org-with-point-at point
            (let* ((props (org-babel-params-from-properties lang))
                   (args (mapcar #'org-babel-parse-header-arguments
	                         (cons (org-element-property :parameters datum)
	                               (org-element-property :header datum))))
                   (blocks (-flatten (append props args))))
              (loop for (key . value) in blocks
                    when (eq key :tangle)

                    if (string= value "yes")
                    collect (expand-file-name
                             (consider-tangle-dir (concat
                                                   (file-name-sans-extension
                                                    (buffer-file-name)) "." ext)))

                    else unless (string= value "no")
                    collect (expand-file-name
                             (consider-tangle-dir value)))))))))))

(defun oldt-collect-tangle-files-in-subtree ()
  (interactive)
  (save-restriction
    (condition-case nil
        (org-narrow-to-subtree)
      (error nil))
    (oldt-collect-tangle-files-in-buffer)))

(defun oldt-collect-project-tangle-files ()
  (save-excursion
    (oldt-goto-project)
    (oldt-collect-tangle-files-in-subtree)))
#+end_src
*** goto tangle file
#+begin_src emacs-lisp
(defun oldt-goto-tangle-file()
  (interactive)
  (if-let (tangle-files (oldt-collect-tangle-files-in-subtree))
      (switch-to-buffer
       (find-file-noselect
        (if (> (length tangle-files) 1)
            (org-completing-read "Choose file to visit: " tangle-files)
          (car tangle-files))
        t))
    (unless tangle-files
      (error "No tangle files all the way down"))))
#+end_src
*** locate el files
#+begin_src emacs-lisp
(defun files-in-below-directory (directory)
  "List the .el files in DIRECTORY and in its sub-directories."
  ;; Although the function will be used non-interactively,
  ;; it will be easier to test if we make it interactive.
  ;; The directory will have a name such as
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; while we are in the current directory
    (while current-directory-list
      (cond
       ;; check to see whether filename ends in '.el'
       ;; and if so, add its name to a list.
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
       ;; check whether filename is that of a directory
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide whether to skip or recurse
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; then do nothing since filename is that of
            ;;   current directory or parent, "." or ".."
            ()
          ;; else descend into the directory and repeat the process
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; move to the next filename in the list; this also
      ;; shortens the list so the while loop eventually comes to an end
      (setq current-directory-list (cdr current-directory-list)))
    ;; return the filenames
    el-files-list))
#+end_src
*** ensure local vars
#+begin_src emacs-lisp
(defun oldt-ensure-local-var(symbol)
  (unless (and (boundp symbol) (local-variable-p symbol))
    (let ((value (read-string (format "%s: " (symbol-name symbol)))))
      (add-file-local-variable symbol value)))
  (eval symbol))
#+end_src
*** build
#+begin_src emacs-lisp
(defun oldt-build ()
  (interactive)
  (let ((project-files (files-in-below-directory "./")))
    (org-babel-tangle)
    (mapc 'load-file project-files)
    (mapc 'byte-compile-file project-files)

    (let* ((org-literate-test-selector (oldt-ensure-local-var 'org-literate-test-selector))
           (org-literate-test-buffer (oldt-ensure-local-var 'org-literate-test-buffer))
           (ert-stats (ert-run-tests-interactively org-literate-test-selector org-literate-test-buffer))
           (expected (ert-stats-completed-expected ert-stats))
           (unexpected (ert-stats-completed-unexpected ert-stats))
           (skipped (ert-stats-skipped ert-stats))
           (total (ert-stats-total ert-stats))
           (report (list "Build finished. Ran %d tests, %d were as expected, %d failed, %d skipped"
                         total expected unexpected skipped)))
      (apply 'message report))))
#+end_src
** Magit integration
#+begin_src emacs-lisp
(defun oldt-magit-workon ()
  "Switch to project branch."
  (interactive)
  (save-window-excursion
    (save-excursion
      (org-clock-goto)
      (let* ((default-directory (oldt-service-get-property "PATH"))
             (branch (oldt-project-get-property "BRANCH"))
             (current-branch (magit-get-current-branch))
             (source (oldt-project-get-property "SOURCE_BRANCH"))
             (staged (magit-staged-files))
             (unstaged (magit-unstaged-files))
             (untracked (magit-untracked-files)))
        (if (string= branch current-branch)
            (message "Already on branch %s" branch)
          (when (y-or-n-p (format "Switch to task branch %s (current %s%s%s%s)?" branch current-branch
                                  (if staged (format ", staged %d files" (length staged)) "")
                                  (if unstaged (format ", unstaged %d files" (length unstaged)) "")
                                  (if untracked (format ", untracked %d files" (length untracked)) "")))
            (magit-branch-or-checkout branch source)
            (magit-branch-checkout branch)))))))
#+end_src
** Helpers
*** "Restart" current task
#+begin_src emacs-lisp
(defun oldt-task-trigger-todo-hook ()
  (interactive)
  (let ((state (oldt-task-get-property "STATE"))
        (default-directory (file-name-directory (buffer-file-name (org-clocking-buffer)))))
    (oldt-trigger-function (list :from state :to "TODO"))))

(defun oldt-task-trigger-start-hook ()
  (interactive)
  (let ((state (oldt-task-get-property "STATE"))
        (default-directory (file-name-directory (buffer-file-name (org-clocking-buffer)))))
    (oldt-trigger-function (list :from "TODO" :to state))))
#+end_src
* Experiments
** project-overview
#+begin_src emacs-lisp
(defun oldt-report (id &rest args)
  (let ((entry-id (or id (org-id-uuid)))
        (report-buffer-name "*oldt-projects-overview*")
        (todo-states "#+TODO: STARTED FAILED | OK"))
    (save-window-excursion
      (switch-to-buffer report-buffer-name)
      (when (string-empty-p (buffer-string))
        (insert todo-states)
        (org-mode))
      (goto-char (point-max))
      (if (not (null id))
          (progn
            (search-backward id)
            (org-back-to-heading)
            (org-todo (car args)))
        (org-insert-heading)
        (apply #'insert args)
        (org-set-property "ID" entry-id)
        ;; (org-back-to-heading)
        ;; (org-set-property "TS" (format-time-string "%Y-%m-%d %H:%M:%S"))
        (org-back-to-heading)
        (org-todo "STARTED")
        (org-overview)))
    entry-id))

(aio-defun oldt-process-report (project-name description promise)
  (let ((log-id (oldt-report nil project-name description)))
    (aio-await promise)
    (let ((result (funcall (aio-result promise))))
      (oldt-report log-id (cond ((> result 0) "FAILED")
                                ((= result 0) "OK"))))))

(aio-defun oldt-git-project-overview (project-directory)
  (let ((process-buffer (generate-new-buffer-name "*project-status*")))
    (loop for .git in (directory-files-recursively project-directory "^.git$" t)
          do (let* ((default-directory (file-name-directory .git))
                    (project-name (format "[[[file+emacs:%s][%s]]] "
                                          default-directory
                                          (file-name-nondirectory
                                           (directory-file-name
                                            default-directory)))))
               (aio-await
                (oldt-process-report project-name "update repository"
                                     (oldt-start-process-async "git-remote-update" process-buffer
                                                               "git" "remote" "update")))
               (aio-await
                (oldt-process-report project-name "git pull"
                                     (oldt-start-process-async "git-pull" process-buffer
                                                               "git" "pull")))
               (kill-buffer process-buffer)))))
#+end_src
** note-reader
#+begin_src emacs-lisp
(setq oldt-note-reader--current-marker nil)

(defun oldt-read-next-note (pom)
  (save-excursion
    (let ((eol (save-excursion
                 (org-goto-marker-or-bmk pom)
                 (re-search-forward org-clock-drawer-end-re)
                 (point-marker))))
    (when (< pom eol)
      (condition-case nil
          (save-excursion
            (org-goto-marker-or-bmk pom)
            (search-forward "Note taken on")
            (point-marker))
        (error nil))))))

(defun oldt-logbook-reader ()
  (interactive)
  (setq oldt-note-reader--current-marker
        (oldt-read-next-note (or oldt-note-reader--current-marker
                                 (save-excursion
                                   (org-back-to-heading)
                                   (re-search-forward ":LOGBOOK:")
                                   (point-marker))))))
#+end_src
** jira-integration
#+begin_src emacs-lisp
(require 'request)

(defvar oldt-jira-login "" "Your Jira email address")
(defvar oldt-jira-api-token "" "Jira API token, see how to generate it here: https://confluence.atlassian.com/cloud/api-tokens-938839638.html")

(defun oldt-jira-get-auth-token ()
  (concat "Basic " (base64-encode-string (concat oldt-jira-login ":" oldt-jira-api-token))))

(defun oldt-jira-get-ticket-summary (ticket callback)
  (request (concat "https://flocktory.atlassian.net/rest/api/latest/issue/" ticket)
           :headers `(("Authorization" . ,(oldt-jira-get-auth-token)))
           :parser 'json-read
           :success callback))

(defun oldt-jira-capture-ticket-title ()
  (when-let (ticket (oldt-project-get-property "TICKET"))
    (oldt-jira-get-ticket-summary ticket
                                  (cl-function
                                   (lambda (&key data &allow-other-keys)
                                     (save-window-excursion
                                       (save-excursion
                                         (let-alist data
                                           (message "Going to last stored headline")
                                           (org-capture-goto-last-stored)
                                           (message "Setting ITEM property extracted from Jira task")
                                           (oldt-project-set-property "ITEM" (concat .fields.summary " [0%]"))))))))))

(defun oldt-jira-update-project-status ()
  (interactive)
  (when-let (ticket (oldt-project-get-property "TICKET"))
    (oldt-jira-get-ticket-summary ticket
                                  (cl-function
                                   (lambda (&key data &allow-other-keys)
                                     (save-window-excursion
                                       (save-excursion
                                         (let-alist data
                                           (message "Setting JIRA_TASK_STATUS property extracted from Jira task")
                                           (oldt-project-set-property "JIRA_TASK_STATUS" .fields.status.name)
                                           (oldt-project-set-property "TODO_STATE"
                                                                      (upcase (s-replace " " "_" .fields.status.name)))
                                           ))))))))

(add-hook 'org-capture-before-finalize-hook 'oldt-jira-capture-ticket-title)
#+end_src
** class-variables
#+begin_src emacs-lisp
(defun oldt-service-add-class-variables (service path vars)
  (dir-locals-set-class-variables service vars)
  (dir-locals-set-directory-class path service))
#+end_src
** clojure-intergration
#+begin_src emacs-lisp
(defun oldt-project-workon--clojure ()
  "Run cider if it is a clojure service."
  (interactive)
  (save-window-excursion
    (save-excursion
      (let* ((proj-dir (oldt-service-get-property "PATH"))
             (clojure-project-fn (concat proj-dir "/project.clj")))
        (when (file-exists-p clojure-project-fn)
          (find-file clojure-project-fn)
          (unless (condition-case nil
                      (cider-nrepl-eval-session)
                    (error nil))
            (call-interactively #'cider-jack-in)))))))
#+end_src
** send-current-to-remote
#+begin_src emacs-lisp
(defun oldt-send-current-to-remote ()
  (interactive)
  (when (and (boundp 'oldt-source-dir)
             (boundp 'oldt-target-dir))
    (copy-file (buffer-file-name)
               (s-replace oldt-source-dir oldt-target-dir (buffer-file-name))
               t)))

(add-hook 'after-save-hook 'oldt-send-current-to-remote)
#+end_src
** tests or something
#+begin_src emacs-lisp
(defun oldt-evaluate-blocks-current-heading ()
  (org-back-to-heading)
  (save-excursion
    (save-restriction
      (org-save-outline-visibility nil
        (narrow-to-region (org-entry-beginning-position) (org-entry-end-position))
        (loop while (condition-case-unless-debug nil (org-babel-next-src-block) (user-error nil))
              collect (org-babel-execute-src-block nil nil '((:results . "silent"))) into report
              finally (return (-all-p (lambda (result) (s-contains-p "success" (downcase result))) report)))))))

(defun oldt-heading-sbe ()
  (interactive)
  (ledna/set-todo-state "LOADING")
  (sit-for 0.2)
  (if (oldt-evaluate-blocks-current-heading)
      (ledna/set-todo-state "PASSED")
    (ledna/set-todo-state "FAILED")))

(defun oldt-reset-tests ()
  (interactive)
  (ledna/set-todo-state "TEST" (ledna/search ":oldt:test_case:" 'tree))
  (org-update-statistics-cookies t))
#+end_src
* Provision
#+begin_src emacs-lisp
(provide 'org-literate-devtools)
;;; org-literate-devtools.el ends here
#+end_src
* Settings
# Local Variables:
# org-literate-test-selector: "^oldt-test-*"
# org-literate-test-buffer: "*oldt-tests*"
# org-use-tag-inheritance: t
# org-source-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
